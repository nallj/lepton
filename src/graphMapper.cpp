
#include "graphMapper.h"


/* PUBLIC */

graphMapper::graphMapper(std::string input_file) :
	input_file_(input_file) {

	// Read in the tgff-2-drachma file
	auto file_handler = fileReader(input_file, t2d_simple_params_, t2d_regex_params_);

	if (file_handler.isFileValid()) {

		// Start by retrieving the basic application parameters.
		auto statically_defined_params = file_handler.getParamsMap();

		// Get the TGFF file where the graph data is populated.
		std::string tgff_file_path = statically_defined_params.find("tgff file")->second;

		// Get the Drachma application file.
		std::string drachma_app_file_path = statically_defined_params.find("drachma app file")->second;

		// Get the number of IPs (i.e. intellectual properties) used to fit the task graph.
		//std::string ip_count_str = statically_defined_params.find("ip count")->second;
		//unsigned ip_count = std::stoul(ip_count_str);

		// Read the Drachma application file for how many static/reconfigurable regions will be present.
		auto app_file_handler = fileReader(drachma_app_file_path, application_params_, application_regex_);

		// Get all the counts.
		countRegionsAndModules(app_file_handler);

		std::vector<std::string> param_data = file_handler.getData();
		std::vector<ipParams> ip_params;
		std::vector<srParams> sr_params;
		std::vector<rrParams> rr_params;

		// Get all supplied mapping parameters.
		collectAllParamMapsFromConfigFile(param_data, ip_params, sr_params, rr_params);

		std::vector<graph*> graphs;

		// Use the .tgff file generated by the .tgffopt file to recreate the graph structures.
		formGraphsFromTgffFile(tgff_file_path, graphs);

		/*
		 * 1. By what means do I choose which IPs are assigned to which nodes?
		 * 		-random
		 * 		-specify which IPs may go on what task type (tedious to support)
		 */
		markGraphTasksWithIps(graphs, ip_params.size());

		// Get region-to-ip mapping approach (either random or lowest cost).
		auto region_to_ip_mapping_approach = statically_defined_params.find("region to ip mapping");
		bool use_random_else_least_cost;

		if (region_to_ip_mapping_approach == statically_defined_params.end() || region_to_ip_mapping_approach->second != "least cost") {
			use_random_else_least_cost = true;
		}

		/*
		 * 2. Perform the mapping of the SRs/RRs to each IP node
		 *		-random
		 *		-least cost fit (tedious to support)
		 */
		
		auto m = mapper(input_file);
		m.mapRegionsToGraphNodesAndProduceTraces(graphs, sr_params, rr_params, ip_params, use_random_else_least_cost);


	} else std::cout << ">>> TGFF-TO-DRACHMA FILE IS CORRUPT!!!\n\n";
}


/* PRIVATE */

void graphMapper::countRegionsAndModules(fileReader app_file_handler) {

	sr_count_ = 0, rr_count_ = 0;
	sr_module_counts_ = std::vector<unsigned>();
	rr_module_counts_ = std::vector<unsigned>();

	std::vector<unsigned>::iterator it;

	unsigned region_id_end_index, region_id, region_id_plus_1, current_rr_module_count;
	std::string region_id_str, module_id_str;
	unsigned module_id_start_index, module_id_end_index, module_id, module_id_plus_1;

	// Start parsing the arbitrary amounts of static and reconfigurable regions.
	std::vector<std::string> dynamically_declared_params = app_file_handler.getData();
	for (int i = 0; i < dynamically_declared_params.size(); i++) {

		// Get the parameter and the corresponding argument.
		std::string param = dynamically_declared_params[i].substr(0, dynamically_declared_params[i].find(":"));
		std::string arg = dynamically_declared_params[i].substr(dynamically_declared_params[i].find(":") + 2);

		// Handle static region parameters.
		if (param.substr(0, 2) == "sr") {

			region_id_end_index = param.find(" ");
			region_id_str = param.substr(2, region_id_end_index - 2);

			region_id = std::stoul(region_id_str);
			region_id_plus_1 = region_id + 1;

			// Record count based off of largest static region ID that is found.
			if (region_id_plus_1 > sr_count_)
				sr_count_ = region_id_plus_1;

			it = sr_module_counts_.begin() + region_id;
			sr_module_counts_.insert(it, std::stoul(arg));
		}

		// Handle reconfigurable region parameters.
		if (param.substr(0, 2) == "rr") {

			region_id_end_index = param.find(" ");
			region_id_str = param.substr(2, region_id_end_index - 2);

			region_id = std::stoul(region_id_str);
			region_id_plus_1 = region_id + 1;

			// Record region count based off of largest reconfigurable region ID that is found.
			if (region_id_plus_1 > rr_count_)
				rr_count_ = region_id_plus_1;

			// If an entry has not been added for this RR, add one first before proceeding.
			if (rr_module_counts_.size() < region_id_plus_1) {

				it = rr_module_counts_.begin() + region_id;
				rr_module_counts_.insert(it, 0);
			}

			current_rr_module_count = rr_module_counts_.at(region_id);

			// Ignore lines concerning bitstream width.
			if (param.substr(region_id_end_index + 1, 3) != "bit") {

				module_id_start_index = param.find("module") + 7;
				module_id_end_index = param.find(" ", module_id_start_index);

				module_id_str = param.substr(module_id_start_index, module_id_end_index - module_id_start_index);

				module_id = std::stoul(module_id_str);
				module_id_plus_1 = module_id + 1;

				// Record module count based off of largest module ID that is found.
				if (current_rr_module_count < module_id_plus_1)
					rr_module_counts_.at(region_id) = module_id_plus_1;
			}
		}

	}

}

void graphMapper::collectAllParamMapsFromConfigFile(
	std::vector<std::string> &param_data,
	std::vector<ipParams> &ip_params,
	std::vector<srParams> &sr_params,
	std::vector<rrParams> &rr_params
) {

	auto parser = parameterParser();

	for (unsigned i = 0; i < param_data.size(); i++) {

		std::string data_string = param_data[i];
		std::size_t colon_position = param_data[i].find(":");

		// Grab parameter and corresponding argument from the data string.
		std::string param = data_string.substr(0, colon_position);
		std::string arg = data_string.substr(colon_position + 1);

		// Trim the argument of any whitespace.
		boost::trim(arg);

		std::size_t space_position;

		std::size_t ip_param_position = param.find("ip");
		if (ip_param_position != std::string::npos) {

			// Parse as an IP parameter.
			parser.parseIpParam(ip_param_position, param, arg, ip_params);

			// Skip other checks.
			continue;
		}

		std::size_t sr_param_position = param.find("sr");
		if (sr_param_position != std::string::npos) {

			// Parse as a SR parameter.
			parser.parseSrParam(sr_param_position, param, arg, sr_params);

			// Skip last check.
			continue;
		}

		std::size_t rr_param_position = param.find("rr");
		if (rr_param_position != std::string::npos) {

			// Parse as a RR parameter.
			parser.parseRrParam(rr_param_position, param, arg, rr_params);
		}
	}

	// DEBUG MESSAGES
	if (DEBUG_COLLECT_CONFIG_PARAMS) {

		std::cout << "\n==============================================================================\n"
					<< " >>> Now printing 'DEBUG_COLLECT_CONFIG_PARAMS' Debug Data\n\n";


		for (int i = 0; i < ip_params.size(); i++) {
			std::cout << "IP#" << i << " <" << ip_params[i].latency_ << ", " << ip_params[i].upper_tolerance_ << ", " << ip_params[i].lower_tolerance_ << ">\n";
		}

		std::cout << "\nTHERE ARE " << sr_params.size() << " SRs TOTAL with module counts = { ";
		for (int i = 0; i < sr_params.size(); i++)
			std::cout << sr_params[i].sr_module_id_to_ip_id_.size() << ", ";
		std::cout << " }\n";


		for (int i = 0; i < sr_params.size(); i++) {
			auto module_ip_ids = sr_params[i].sr_module_id_to_ip_id_;

			std::cout << "> SR " << i << " has " << module_ip_ids.size() << " Modules with the following respective IPs = { ";
			for (int j = 0; j < module_ip_ids.size(); j++)
				std::cout << "ip" << module_ip_ids[j] << ", ";

			std::cout << " }\n";
		}


		std::cout << "\nTHERE ARE " << rr_params.size() << " RRs TOTAL with module counts = { ";
		for (int i = 0; i < rr_params.size(); i++)
			std::cout << rr_params[i].rr_module_id_to_ip_ids_.size() << ", ";
		std::cout << " }\n";


		for (int i = 0; i < rr_params.size(); i++) {
			auto module_ip_ids = rr_params[i].rr_module_id_to_ip_ids_;

			for (int j = 0; j < module_ip_ids.size(); j++) {
				std::cout << ">> RR " << i << ", Module " << j << " has ";

				auto ip_ids = module_ip_ids[j];
				std::cout << "[" << ip_ids.size() << "] { ";

				for (int k = 0; k < ip_ids.size(); k++) {
					std::cout << "ip" << ip_ids[k] << ", ";
				}

				std::cout << "}\n";
			}
		}

		std::cout << "\n >>> Finished printing 'DEBUG_COLLECT_CONFIG_PARAMS' Debug Data"
					<< "\n==============================================================================\n";
	}

}

void graphMapper::formGraphsFromTgffFile(std::string input_file, std::vector<graph*> &graphs) {

	std::ifstream in_file(input_file.c_str());
	std::string line;

	bool building_graph = false;
	graph* current_graph;

	// Loop through the .tgff file and build all graph structures.
	while (std::getline(in_file, line)) {


		// Search for the beginning of a graph specification.
		if (!building_graph) {

			// If found begin building a new graph.
			if (line.find("@TASK_GRAPH") != std::string::npos) {

				building_graph = true;
				current_graph = new graph();
			}

			continue;

		// If the end of a graph specification has been reached save the graph and continue searching the file.
		} else if (line.length() > 0 && line.at(0) == '}') {

			// Before saving the graph determine the top level nodes for the graph.
			current_graph->determineTopNodes();

			building_graph = false;
			graphs.push_back(current_graph);

			continue;
		}

		std::size_t position, space_position;

		// Check for task node specification.
		position = line.find("TASK");

		if (position != std::string::npos) {

			space_position = line.find("\t", position + 5);
			std::string node_id = line.substr(position + 5, space_position - position - 5);

			position = line.find("TYPE");

			std::string task_type_id_string = line.substr(position + 5);
			boost::trim(task_type_id_string);

			unsigned task_type_id = std::stoul(task_type_id_string);

			// Add node to the graph and continue to the next line in the graph specification.
			current_graph->addGraphNode(node_id, task_type_id);
			continue;
		}

		// Check for node edge specification.
		position = line.find("ARC");

		if (position != std::string::npos) {

			space_position = line.find(" ", position + 4);
			std::string edge_id = line.substr(position + 4, space_position - position - 4);

			position = line.find("FROM");
			space_position = line.find(" ", position + 5);

			std::string from_id_string = line.substr(position + 5, space_position - position - 5);

			position = line.find("TO");
			space_position = line.find(" ", position + 4);

			std::string to_id_string = line.substr(position + 4, space_position - position - 4);

			// Add the successor node under the target predecessor node.
			current_graph->addSuccessorToNode(from_id_string, to_id_string);
			continue;
		}

	}
	in_file.close();

	// DEBUG MESSAGES
	if (DEBUG_FORM_GRAPHS) {

		std::cout << "\n==============================================================================\n"
					<< " >>> Now printing 'DEBUG_FORM_GRAPHS' Debug Data\n\n";

		for (unsigned i = 0; i < graphs.size(); i++) {

			std:: cout << "> This is graph # " << i << " and it has nodes:\n";

			std::vector<graphNode*> all_nodes = graphs[i]->getAllNodes();

			for (unsigned j = 0; j < all_nodes.size(); j++) {
				std::cout << "\t" << all_nodes[j]->getNodeId() << " (type " << all_nodes[j]->getTaskTypeId() << ")";

				std::vector<graphNode*> successor_nodes = all_nodes[j]->getSuccessorNodes();

				if (successor_nodes.size() > 0)
					std::cout << "\n\t\twith successor nodes: ";
				else
					std::cout << " <no successor nodes>";

				for (unsigned k = 0; k < successor_nodes.size(); k++) {
					std::cout << successor_nodes[k]->getNodeId() << ", ";
				}

				std::cout << "\n";
			}

			std:: cout << "  And has the following top nodes:\n";

			std::deque<graphNode*> all_top_level_nodes = graphs[i]->getAllTopLevelNodes();
			for (unsigned j = 0; j < all_top_level_nodes.size(); j++) {
					std::cout << "\t" << all_top_level_nodes[j]->getNodeId() << " (" << all_top_level_nodes[j]->getTaskTypeId() << ")\n";
			}

		}

		std::cout << "\n >>> Finished printing 'DEBUG_FORM_GRAPHS' Debug Data"
					<< "\n==============================================================================\n";
	}

}

// TODO: Support user specified restrictions on which IPs may match with which task types.
void graphMapper::markGraphTasksWithIps(std::vector<graph*> &graphs, unsigned ip_count) {

	// TODO: This should be derived from configuration parameters, otherwise set to 0.
	bool use_time_as_random_seed = false;
	unsigned random_seed;

	if (use_time_as_random_seed)
		random_seed = (unsigned) time(0);
	else
		random_seed = 5762;

	// Feed the seed to the pseudo-random number generator.
	srand(random_seed);

	// Perform marking activities for each graph.
	for (std::vector<graph*>::iterator it = graphs.begin(); it != graphs.end(); ++it) {

		std::deque<graphNode*> all_top_level_nodes = (*it)->getAllTopLevelNodes();
		for (unsigned i = 0; i < all_top_level_nodes.size(); i++) {

			// Recursively travel from every top level node to mark every node with a pseudo-randomly chosen IP.
			markGraphTasksWithIpsRecursive(all_top_level_nodes[i], ip_count);
		}
	}

	// DEBUG MESSAGES
	if (DEBUG_MARK_GRAPHS) {

		std::cout << "\n==============================================================================\n"
					<< " >>> Now printing 'DEBUG_MARK_GRAPHS' Debug Data\n\n";

		for (unsigned i = 0; i < graphs.size(); i++) {

			std:: cout << "> This is graph # " << i << " and it has nodes:\n";

			std::vector<graphNode*> all_nodes = graphs[i]->getAllNodes();

			for (unsigned j = 0; j < all_nodes.size(); j++)
				std::cout << "\t" << all_nodes[j]->getNodeId() << " (IP" << all_nodes[j]->getIpId() << ")\n";
		}

		std::cout << "\n >>> Finished printing 'DEBUG_MARK_GRAPHS' Debug Data"
					<< "\n==============================================================================\n";
	}

}

void graphMapper::markGraphTasksWithIpsRecursive(graphNode* node, unsigned ip_count) {

	// Mark the node with the chosen ID.
	unsigned random_ip_id = rand() % static_cast<unsigned>(ip_count);
	node->setIpId(random_ip_id);

	std::vector<graphNode*> successors = node->getSuccessorNodes();

	// Continue recursive marking if there are any successor nodes.
	if (successors.size() > 0)

		for (std::vector<graphNode*>::iterator it = successors.begin(); it != successors.end(); ++it)
			markGraphTasksWithIpsRecursive(*it, ip_count);
}
