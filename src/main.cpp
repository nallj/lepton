#include <iostream>
#include <utility>
#include <stdexcept>
#include <stdlib.h>
#include <string>
#include <unordered_map>
#include <vector>

#include "graph/graphHandler.h"
#include "graph/graphMapper.h"
#include "helpers/moduleHelper.h"
#include "parameters/parameterBuilder.h"
#include "parameters/parameterParser.h"

unsigned long findSeedOrAssignFromTime(params_map_t statically_defined_params, std::string static_key) {
	auto random_seed_arg = statically_defined_params.find(static_key);
	if (random_seed_arg != statically_defined_params.end()) {
		return std::stoul(random_seed_arg->second);
	}
	return (unsigned long) time(0);
}

moduleSelectionType getRegionToIpMappingApproach(params_map_t statically_defined_params) {
	auto region_to_ip_mapping_approach = statically_defined_params.find("region to ip mapping");
	moduleSelectionType module_selection_method;

	if (
		region_to_ip_mapping_approach == statically_defined_params.end() ||
		region_to_ip_mapping_approach->second == "random"
	) {
		return moduleSelectionType::random;
	}
	if (region_to_ip_mapping_approach->second == "least cost") {
		return moduleSelectionType::least_cost;
	}
	throw std::invalid_argument("Invalid region-to-IP mapping approach.");
}
			


int main(int argc, char** argv) {

	std::cout << "\nLepton : Utility program for producing Drachma application traces from TGFF outputs.\n\n";
	try {

		// Input file given.
		if (argc > 1 && argc < 3 && argv[1][0] != 0) {

			auto lepton_spec_file_path = argv[1];
			auto parameter_parser = parameterParser(); 

			// Start by retrieving the basic trace generation specification parameters.
			auto spec_file_contents = parameter_parser.parseLeptonSpecificationFile(lepton_spec_file_path);

			// Unpack parameters and data.
			auto statically_defined_params = spec_file_contents.params_map;
			auto param_data = spec_file_contents.data;

			// Get seeds for randomness.
			auto handler_random_seed = findSeedOrAssignFromTime(
				statically_defined_params,
				"handler random seed"
			);
			std::cout << "\thandler random seed: " << handler_random_seed << "\n";

			auto mapper_random_seed = findSeedOrAssignFromTime(
				statically_defined_params,
				"mapper random seed"
			);
			std::cout << "\tmapper random seed: " << mapper_random_seed << "\n\n\n";

			// Get the Drachma application file.
			// auto drachma_app_file_path = statically_defined_params.find("drachma app file")->second;

			// Get all the region and module counts.
			// auto counts = parameter_parser.countRegionsAndModules(drachma_app_file_path);

			auto parameter_builder = parameterBuilder();

			// Get all supplied mapping parameters.
			auto all_params = parameter_builder.collectAllParamMapsFromConfigFile(param_data);

			auto ip_params_map = all_params.ip_params_map;
			auto sr_params_map = all_params.sr_params_map;
			auto rr_params_map = all_params.rr_params_map;

			auto graph_handler = graphHandler();

			// Get the TGFF file where the graph data is populated.
			auto tgff_file_path = statically_defined_params.find("tgff file")->second;

			// Use the .tgff file generated by the .tgffopt file to recreate the graph structures.
			auto graphs = graph_handler.formGraphsFromTgffFile(tgff_file_path);

			/*
			 * 1. By what means do I choose which IPs are assigned to which nodes?
			 * 		-random
			 * 		-specify which IPs may go on what task type (TODO)
			 */

			graph_handler.markGraphTasksWithIps(graphs, ip_params_map.size(), handler_random_seed);

			/*
			 * 2. Perform the mapping of the SRs/RRs to each IP node
			 *		-random (default)
			 *		-least cost fit (TODO)
			 */

			// Get region-to-ip mapping approach (either random or lowest cost).
			auto module_selection_method = getRegionToIpMappingApproach(statically_defined_params);

			// Build two vectors (static and reconfigurable) of regions matched to vectors of all available
			// modules per each region.
			auto available_sr_modules = moduleHelper::buildSrToAvailableModuleMap(sr_params_map);
			auto available_rr_modules = moduleHelper::buildRrToAvailableModuleMap(rr_params_map);

			ip_to_capable_modules_map_t ip_to_capable_modules_map;

			// Create an IP-to-capable module map.
			moduleHelper::buildIpToSrModuleMap(sr_params_map, available_sr_modules, ip_to_capable_modules_map);
			moduleHelper::buildIpToRrModuleMap(rr_params_map, available_rr_modules, ip_to_capable_modules_map);

			auto graph_mapper = graphMapper(lepton_spec_file_path);

			graph_mapper.mapRegionsToGraphNodesAndProduceTraces(
				graphs,
				ip_params_map,
				available_sr_modules,
				available_rr_modules,
				ip_to_capable_modules_map,
				module_selection_method,
				mapper_random_seed
			);

		// Too many arguments supplied.
		} else if (argc > 1) {
			throw std::invalid_argument("Too many arguments supplied!  Please specify the input file as the only program argument.");

		// No input file was supplied.
		} else {
			throw std::invalid_argument("No input file supplied!  Please specify one as the only program argument.");
		}

	} catch (std::exception& e) {
		std::cout << "> ERROR: " << e.what() << "\n\n";
		return EXIT_FAILURE;
	}

	std::cout << "\n\n> DONE!\n\n";
	return EXIT_SUCCESS;
}
