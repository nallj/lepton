#include <iostream>
#include <utility>
#include <stdexcept>
#include <stdlib.h>
#include <string>
#include <unordered_map>
#include <vector>

#include "graph/graphHandler.h"
#include "graph/graphMapper.h"
#include "graph/moduleHelper.h"
#include "parameters/parameterBuilder.h"
#include "parameters/parameters.h"
#include "parameters/parameterParser.h"


int main(int argc, char** argv) {

	std::cout << "\nLepton : Utility program for producing Drachma application traces from TGFF outputs.\n\n\n";

	try {

		// Input file given.
		if (argc > 1 && argc < 3 && argv[1][0] != 0) {

			auto lepton_spec_file_path = argv[1];
			auto parameter_parser = parameterParser(); 

			// Start by retrieving the basic trace generation specification parameters.
			auto spec_file_contents = parameter_parser.parseLeptonSpecificationFile(lepton_spec_file_path);

			// Unpack parameters and data.
			auto statically_defined_params = spec_file_contents.params_map;
			auto param_data = spec_file_contents.data;

			// Get the Drachma application file.
			auto drachma_app_file_path = statically_defined_params.find("drachma app file")->second;

			// Get all the region and module counts.
			auto counts = parameter_parser.countRegionsAndModules(drachma_app_file_path);

			// Prepare containers for relevant specification parameters.
			//std::vector<ipParams> ip_params;
			//std::vector<srParams> sr_params;
			//std::vector<rrParams> rr_params;



			//sr_params_map_t sr_params_map;
			//rr_params_map_t rr_params_map;

			auto parameter_builder = parameterBuilder();

			// Get all supplied mapping parameters.
			auto all_params = parameter_builder.collectAllParamMapsFromConfigFile(param_data);

			auto ip_params_map = all_params.ip_params_map;
			auto sr_params_map = all_params.sr_params_map;
			auto rr_params_map = all_params.rr_params_map;

			//std::vector<std::shared_ptr<graph>> graphs;
			auto graph_handler = graphHandler();

			// Get the TGFF file where the graph data is populated.
			auto tgff_file_path = statically_defined_params.find("tgff file")->second;

			// Use the .tgff file generated by the .tgffopt file to recreate the graph structures.
			auto graphs = graph_handler.formGraphsFromTgffFile(tgff_file_path);

			/*
			* 1. By what means do I choose which IPs are assigned to which nodes?
			* 		-random
			* 		-specify which IPs may go on what task type (tedious to support)
			*/
			graph_handler.markGraphTasksWithIps(graphs, ip_params_map.size());

			// Get region-to-ip mapping approach (either random or lowest cost).
			auto region_to_ip_mapping_approach = statically_defined_params.find("region to ip mapping");
			moduleSelectionType module_selection_method;

			if (region_to_ip_mapping_approach == statically_defined_params.end() || region_to_ip_mapping_approach->second != "least cost") {
				module_selection_method = moduleSelectionType::random;
			}

			/*
			* 2. Perform the mapping of the SRs/RRs to each IP node
			*		-random
			*		-least cost fit (tedious to support)
			*/

			auto module_helper = moduleHelper();

			// Build two vectors (static and reconfigurable) of regions matched to vectors of all available modules per each region.
			//module_helper.buildRegionToAvailableModuleVectors(available_sr_modules, sr_params_map, available_rr_modules, rr_params_map);

			auto available_sr_modules = module_helper.buildSrToAvailableModuleMap(sr_params_map);
			auto available_rr_modules = module_helper.buildRrToAvailableModuleMap(rr_params_map);

			ip_to_capable_modules_map_t ip_to_capable_modules_map;

			// Create an IP-to-available module map.
			//auto ip_to_capable_modules_map =
			//	module_helper.buildIpToModuleMaps(sr_params_map, available_sr_modules, rr_params_map, available_rr_modules);
			module_helper.buildIpToSrModuleMap(sr_params_map, available_sr_modules, ip_to_capable_modules_map);
			module_helper.buildIpToRrModuleMap(rr_params_map, available_rr_modules, ip_to_capable_modules_map);

			auto graph_mapper = graphMapper(lepton_spec_file_path);

			graph_mapper.mapRegionsToGraphNodesAndProduceTraces(graphs, ip_params_map, available_sr_modules,
				available_rr_modules, ip_to_capable_modules_map, module_selection_method);

		// Too many arguments supplied.
		} else if (argc > 1) {
			throw std::invalid_argument("Too many arguments supplied!  Please specify the input file as the only program argument.");

		// No input file was supplied.
		} else {
			throw std::invalid_argument("No input file supplied!  Please specify one as the only program argument.");
		}

	} catch (std::exception& e) {
		std::cout << "> ERROR: " << e.what() << "\n\n";
		return EXIT_FAILURE;
	}

	std::cout << "\n\n> DONE!\n\n";
	return EXIT_SUCCESS;
}
